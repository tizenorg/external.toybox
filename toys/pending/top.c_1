/* top.c - A top world program.
 *
 * Copyright 2012 Rob Landley <rob@landley.net>
 *
 * Not in SUSv4.
 * See http://opengroup.org/onlinepubs/9699919799/utilities/

USE_TOP(NEWTOY(top, "m#n#d#s:th", TOYFLAG_USR|TOYFLAG_BIN))

config TOP
  bool "top"
  default n
  help
    usage: top [ -m max_procs ] [ -n iterations ] [ -d delay ] [ -s sort_column ] [ -t ]

    -m num  Maximum number of processes to display.
    -n num  Updates to show before exiting.
    -d num  Seconds to wait between updates.
    -s col  Column to sort by (cpu,vss,rss,thr).
    -t      Show threads instead of processes.
*/

/*
 * Copyright (c) 2008, The Android Open Source Project
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *  * Redistributions of source code must retain the above copyright
 *  notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright
 *  notice, this list of conditions and the following disclaimer in
 *  the documentation and/or other materials provided with the 
 *  distribution.
 *  * Neither the name of Google, Inc. nor the names of its contributors
 *  may be used to endorse or promote products derived from this
 *  software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED 
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#define FOR_top
#include "toys.h"
#include <unistd.h>
#include <termios.h>
#include <poll.h>

GLOBALS(
  char *s;
  long d;
  long n;
  long m;
)

struct cpu_info {
  long unsigned utime, ntime, stime, itime;
  long unsigned iowtime, irqtime, sirqtime;
};

#define PROC_NAME_LEN 64
#define THREAD_NAME_LEN 32

struct proc_info {
  struct proc_info *next;
  pid_t pid;
  pid_t ppid;
  pid_t tid;
  uid_t uid;
  gid_t gid;
  char name[PROC_NAME_LEN];
  char tname[THREAD_NAME_LEN];
  char state;
  long unsigned utime;
  long unsigned stime;
  long unsigned delta_utime;
  long unsigned delta_stime;
  long unsigned delta_time;
  long vss;
  long rss;
  int prs;
  int num_threads;
  char policy[32];
};

struct proc_list {
  struct proc_info **array;
  int size;
};

#define die(...) { fprintf(stderr, __VA_ARGS__); exit(EXIT_FAILURE); }

#define INIT_PROCS 50
#define THREAD_MULT 8
static struct proc_info **old_procs, **new_procs;
static int num_old_procs, num_new_procs;
static struct proc_info *free_procs;
static int num_used_procs, num_free_procs;

static int max_procs, delay, iterations, threads;

static struct cpu_info old_cpu, new_cpu;

static struct proc_info *alloc_proc(void);
static void free_proc(struct proc_info *proc);
static void read_procs(void);
static int read_stat(char *filename, struct proc_info *proc);
static void read_policy(int pid, struct proc_info *proc);
static void add_proc(int proc_num, struct proc_info *proc);
static int read_cmdline(char *filename, struct proc_info *proc);
static int read_status(char *filename, struct proc_info *proc);
static void print_procs(void);
static struct proc_info *find_old_proc(pid_t pid, pid_t tid);
static void free_old_procs(void);
static int (*proc_cmp)(const void *a, const void *b);
static int proc_cpu_cmp(const void *a, const void *b);
static int proc_vss_cmp(const void *a, const void *b);
static int proc_rss_cmp(const void *a, const void *b);
static int proc_thr_cmp(const void *a, const void *b);
static int numcmp(long long a, long long b);
static void usage(char *cmd);
static unsigned int read_input(int delay);

#if 0
int top_main1(int argc, char *argv[]) 
{
  printf("The count = %d, %s ....... %s\n", toys.optc, toys.argv[0], toys.argv[1]);
  top_main1(toys.optc+2, toys.argv);
}
#endif

void* catch_signal1(int signum)
{
  printf("\n\n\n got signal \n\n\n");
  exit(1);
}

void top_main(void )
{
  int i;

  num_used_procs = num_free_procs = 0;

  max_procs = 0;
  delay = 3;
  iterations = -1;
  proc_cmp = &proc_cpu_cmp;


  if(toys.optflags & FLAG_m)
      max_procs = TT.m;
  if(toys.optflags & FLAG_n)
      iterations = TT.n;
  if(toys.optflags & FLAG_d)
      delay = TT.d;
  if(toys.optflags & FLAG_t)
      threads = 1;
  if(toys.optargs[0])
  {
      fprintf(stderr, "Invalid argument \"%s\".\n", toys.optargs[0]);
      usage(toys.argv[0]);
      exit(EXIT_FAILURE);
  }

#if 0
  for (i = 1; i < argc; i++) {
      if (!strcmp(argv[i], "-m")) {
          if (i + 1 >= argc) {
              fprintf(stderr, "Option -m expects an argument.\n");
              usage(argv[0]);
              exit(EXIT_FAILURE);
          }
          max_procs = atoi(argv[++i]);
          continue;
      }
      if (!strcmp(argv[i], "-n")) {
          if (i + 1 >= argc) {
              fprintf(stderr, "Option -n expects an argument.\n");
              usage(argv[0]);
              exit(EXIT_FAILURE);
          }
          iterations = atoi(argv[++i]);
          continue;
      }
      if (!strcmp(argv[i], "-d")) {
          if (i + 1 >= argc) {
              fprintf(stderr, "Option -d expects an argument.\n");
              usage(argv[0]);
              exit(EXIT_FAILURE);
          }
          delay = atoi(argv[++i]);
          continue;
      }
      if (!strcmp(argv[i], "-s")) {
          if (i + 1 >= argc) {
              fprintf(stderr, "Option -s expects an argument.\n");
              usage(argv[0]);
              exit(EXIT_FAILURE);
          }
          ++i;
          if (!strcmp(argv[i], "cpu")) { proc_cmp = &proc_cpu_cmp; continue; }
          if (!strcmp(argv[i], "vss")) { proc_cmp = &proc_vss_cmp; continue; }
          if (!strcmp(argv[i], "rss")) { proc_cmp = &proc_rss_cmp; continue; }
          if (!strcmp(argv[i], "thr")) { proc_cmp = &proc_thr_cmp; continue; }
          fprintf(stderr, "Invalid argument \"%s\" for option -s.\n", argv[i]);
          exit(EXIT_FAILURE);
      }
      if (!strcmp(argv[i], "-t")) { threads = 1; continue; }
      if (!strcmp(argv[i], "-h")) {
          usage(argv[0]);
          exit(EXIT_SUCCESS);
      }
      fprintf(stderr, "Invalid argument \"%s\".\n", argv[i]);
      usage(argv[0]);
      exit(EXIT_FAILURE);
  }
#endif

  if (threads && proc_cmp == &proc_thr_cmp) {
      fprintf(stderr, "Sorting by threads per thread makes no sense!\n");
      exit(EXIT_FAILURE);
  }

  free_procs = NULL;

  num_new_procs = num_old_procs = 0;
  new_procs = old_procs = NULL;

  sigatexit(catch_signal1);
  read_procs();
  while ((iterations == -1) || (iterations-- > 0)) {
      old_procs = new_procs;
      num_old_procs = num_new_procs;
      memcpy(&old_cpu, &new_cpu, sizeof(old_cpu));
//      sleep(delay);
      read_procs();
      print_procs();
      free_old_procs();
      if(read_input(delay))
          break;
  }

//  return 0;
}

static unsigned int read_input(int delay)
{
  struct pollfd pfd[1];
  int ret, fret = 0;
  int timeout = delay * 1000; //to convert it to msec.
  char ch;
  struct termios inf, newf;
  pfd[0].fd = 0;
  pfd[0].events = POLLIN;

  /*prepare terminal for input, without Enter of Carriage return */
  tcgetattr(0, &inf);
  memcpy(&newf, &inf, sizeof(struct termios));
  newf.c_lflag &= ~(ICANON | ECHO | ECHONL);
  tcsetattr(0, TCSANOW, &newf);

  while(1)
  {
      if((ret = poll(pfd, 1, timeout)) >= 0) {
          xprintf("Poll got an value\n");
          break;
      }
      else
      {
          if(timeout > 0)
              timeout--;
          if(errno == EINTR) {
              printf("signal aaya re .... signal aaya\n\n\n\n");
              continue;
          }
          xprintf("Poll got an error\n");
          fret = 0;
      }
  }
  if(ret <= 0)
  {
      fret = 0;
  }
  else
  {
      if(read(STDIN_FILENO, &ch, 1) != 1)
      {
          fret = 0;
      }
      else if(ch == 'q')
          fret = 1;

  }
  tcsetattr(0, TCSANOW, &inf);
  return fret;
}

static struct proc_info *alloc_proc(void) {
  struct proc_info *proc;

  if (free_procs) {
      proc = free_procs;
      free_procs = free_procs->next;
      num_free_procs--;
  } else {
      proc = malloc(sizeof(*proc));
      if (!proc) die("Could not allocate struct process_info.\n");
  }

  num_used_procs++;

  return proc;
}

static void free_proc(struct proc_info *proc) {
  proc->next = free_procs;
  free_procs = proc;

  num_used_procs--;
  num_free_procs++;
}

#define MAX_LINE 256

static void read_procs(void) {
  DIR *proc_dir, *task_dir;
  struct dirent *pid_dir, *tid_dir;
  char filename[64];
  FILE *file;
  int proc_num;
  struct proc_info *proc;
  pid_t pid, tid;

  int i;

  proc_dir = opendir("/proc");
  if (!proc_dir) die("Could not open /proc.\n");

  new_procs = calloc(INIT_PROCS * (threads ? THREAD_MULT : 1), sizeof(struct proc_info *));
  num_new_procs = INIT_PROCS * (threads ? THREAD_MULT : 1);

  file = fopen("/proc/stat", "r");
  if (!file) die("Could not open /proc/stat.\n");
  fscanf(file, "cpu  %lu %lu %lu %lu %lu %lu %lu", &new_cpu.utime, &new_cpu.ntime, &new_cpu.stime,
          &new_cpu.itime, &new_cpu.iowtime, &new_cpu.irqtime, &new_cpu.sirqtime);
  fclose(file);

  proc_num = 0;
  while ((pid_dir = readdir(proc_dir))) {
      if (!isdigit(pid_dir->d_name[0]))
          continue;

      pid = atoi(pid_dir->d_name);
      
      struct proc_info cur_proc;
      
      if (!threads) {
          proc = alloc_proc();

          proc->pid = proc->tid = pid;

          sprintf(filename, "/proc/%d/stat", pid);
          read_stat(filename, proc);

          sprintf(filename, "/proc/%d/cmdline", pid);
          read_cmdline(filename, proc);

          sprintf(filename, "/proc/%d/status", pid);
          read_status(filename, proc);

          read_policy(pid, proc);

          proc->num_threads = 0;
      } else {
          sprintf(filename, "/proc/%d/cmdline", pid);
          read_cmdline(filename, &cur_proc);

          sprintf(filename, "/proc/%d/status", pid);
          read_status(filename, &cur_proc);
          
          proc = NULL;
      }

      sprintf(filename, "/proc/%d/task", pid);
      task_dir = opendir(filename);
      if (!task_dir) continue;

      while ((tid_dir = readdir(task_dir))) {
          if (!isdigit(tid_dir->d_name[0]))
              continue;

          if (threads) {
              tid = atoi(tid_dir->d_name);

              proc = alloc_proc();

              proc->pid = pid; proc->tid = tid;

              sprintf(filename, "/proc/%d/task/%d/stat", pid, tid);
              read_stat(filename, proc);

              read_policy(tid, proc);

              strcpy(proc->name, cur_proc.name);
              proc->uid = cur_proc.uid;
              proc->gid = cur_proc.gid;

              add_proc(proc_num++, proc);
          } else {
              proc->num_threads++;
          }
      }

      closedir(task_dir);
      
      if (!threads)
          add_proc(proc_num++, proc);
  }

  for (i = proc_num; i < num_new_procs; i++)
      new_procs[i] = NULL;

  closedir(proc_dir);
}

static int read_stat(char *filename, struct proc_info *proc) {
  FILE *file;
  char buf[MAX_LINE], *open_paren, *close_paren;
  int res, idx;

  file = fopen(filename, "r");
  if (!file) return 1;
  fgets(buf, MAX_LINE, file);
  fclose(file);

  /* Split at first '(' and last ')' to get process name. */
  open_paren = strchr(buf, '(');
  close_paren = strrchr(buf, ')');
  if (!open_paren || !close_paren) return 1;

  *open_paren = *close_paren = '\0';
  strncpy(proc->tname, open_paren + 1, THREAD_NAME_LEN);
  proc->tname[THREAD_NAME_LEN-1] = 0;
  
  /* Scan rest of string. */
  sscanf(close_paren + 1, " %c %d %*d %*d %*d %*d %*d %*d %*d %*d %*d "
               "%lu %lu %*d %*d %*d %*d %*d %*d %*d %lu %ld "
               "%*d %*d %*d %*d %*d %*d %*d %*d %*d %*d %*d %*d %*d %*d %d",
               &proc->state, &proc->ppid, &proc->utime, &proc->stime, &proc->vss, &proc->rss, &proc->prs);

  return 0;
}

static void add_proc(int proc_num, struct proc_info *proc) {
  int i;

  if (proc_num >= num_new_procs) {
      new_procs = realloc(new_procs, 2 * num_new_procs * sizeof(struct proc_info *));
      if (!new_procs) die("Could not expand procs array.\n");
      for (i = num_new_procs; i < 2 * num_new_procs; i++)
          new_procs[i] = NULL;
      num_new_procs = 2 * num_new_procs;
  }
  new_procs[proc_num] = proc;
}

static int read_cmdline(char *filename, struct proc_info *proc) {
  FILE *file;
  char line[MAX_LINE];

  line[0] = '\0';
  file = fopen(filename, "r");
  if (!file) return 1;
  fgets(line, MAX_LINE, file);
  fclose(file);
  if (strlen(line) > 0) {
  //    printf("%s\n", line);
      strncpy(proc->name, line, PROC_NAME_LEN);
      proc->name[PROC_NAME_LEN-1] = 0;
  } else
      proc->name[0] = 0;
  return 0;
}

static void read_policy(int pid, struct proc_info *proc) {
          strcpy(proc->policy, "fg");
#if 0
  SchedPolicy p;
  if (get_sched_policy(pid, &p) < 0)
      strcpy(proc->policy, "unk");
  else {
      if (p == SP_BACKGROUND)
          strcpy(proc->policy, "bg");
      else if (p == SP_FOREGROUND)
          strcpy(proc->policy, "fg");
      else
          strcpy(proc->policy, "er");
  }
#endif
}

static int read_status(char *filename, struct proc_info *proc) {
  FILE *file;
  char line[MAX_LINE];
  unsigned int uid, gid;

  file = fopen(filename, "r");
  if (!file) return 1;
  while (fgets(line, MAX_LINE, file)) {
      sscanf(line, "Uid: %u", &uid);
      sscanf(line, "Gid: %u", &gid);
  }
  fclose(file);
  proc->uid = uid; proc->gid = gid;
  return 0;
}
static unsigned long long convert(unsigned long d, unsigned int iscale,
                      unsigned int oscale)
{
      return ((unsigned long long)d*iscale)>>oscale;
}

static char* show_percent(int num, int den)
{
  div_t result;
  char *quot, *rem;
  result = div((num * 100), den);
  quot = xmsprintf("%s",itoa(result.quot));
  rem = xmsprintf("%s", itoa(result.rem));
  return xmsprintf("%s.%c%%",quot, *rem);
  printf("%d.%d%%", result.quot, '0' + result.rem);
}

static void print_procs(void) {
  int i;
  struct proc_info *old_proc, *proc;
  long unsigned total_delta_time;
  struct passwd *user;
  struct group *group;
  char *user_str, user_buf[20];
  char *group_str, group_buf[20];
  struct sysinfo info;
  unsigned int oscale = 0, iscale = 1;
  unsigned int cols=0, rows =0;

  /*determine terminal size */
  terminal_size(&cols, &rows);
  if(rows == 0)
      rows = 40; //40 rows by default.
  /*Clear and display again*/
//  printf("\033[H\033[J");
  rows--;

  for (i = 0; i < num_new_procs; i++) {
      if (new_procs[i]) {
          old_proc = find_old_proc(new_procs[i]->pid, new_procs[i]->tid);
          if (old_proc) {
              new_procs[i]->delta_utime = new_procs[i]->utime - old_proc->utime;
              new_procs[i]->delta_stime = new_procs[i]->stime - old_proc->stime;
          } else {
              new_procs[i]->delta_utime = 0;
              new_procs[i]->delta_stime = 0;
          }
          new_procs[i]->delta_time = new_procs[i]->delta_utime + new_procs[i]->delta_stime;
      }
  }

  total_delta_time = (new_cpu.utime + new_cpu.ntime + new_cpu.stime + new_cpu.itime
                      + new_cpu.iowtime + new_cpu.irqtime + new_cpu.sirqtime)
                   - (old_cpu.utime + old_cpu.ntime + old_cpu.stime + old_cpu.itime
                      + old_cpu.iowtime + old_cpu.irqtime + old_cpu.sirqtime);

  qsort(new_procs, num_new_procs, sizeof(struct proc_info *), proc_cmp);

  /*Memory details */
  sysinfo(&info);
  if (info.mem_unit) iscale = info.mem_unit;
  oscale = 10;
  xprintf("Mem: %lluK used, %lluK free, %lluK shared, %lluK buff\n",
          convert(info.totalram-info.freeram, iscale, oscale),
          convert(info.freeram, iscale, oscale),
          convert(info.sharedram, iscale, oscale),
          convert(info.bufferram, iscale, oscale));
  rows--;
//  printf("\n\n\n");
  printf("CPU: User %s System %s, IOW %s",
          show_percent((new_cpu.utime - old_cpu.utime), total_delta_time),
          show_percent(((new_cpu.stime ) - (old_cpu.stime)), total_delta_time),
          show_percent((new_cpu.iowtime - old_cpu.iowtime), total_delta_time));
  printf(" Nice %s Idle %s IRQ %s SIRQ %s\n",
          show_percent(new_cpu.ntime - old_cpu.ntime, total_delta_time),
          show_percent(new_cpu.itime - old_cpu.itime, total_delta_time),
          show_percent(new_cpu.irqtime - old_cpu.irqtime, total_delta_time),
          show_percent(new_cpu.sirqtime - old_cpu.sirqtime, total_delta_time));
  xprintf("Load average: %0.2f %0.2f %0.2f\n",(float)(info.loads[0]/((float)(1 << SI_LOAD_SHIFT))),
          (float)(info.loads[1]/((float)(1 << SI_LOAD_SHIFT))),
          (float)(info.loads[2]/((float)(1 << SI_LOAD_SHIFT))));
  printf("\n");
  rows -= 3;
#if 0 //Ashwini
  if (!threads) 
      printf("%5s %2s %4s %1s %5s %7s %7s %3s %-8s %s\n", "PID", "PR", "CPU%", "S", "#THR", "VSS", "RSS", "PCY", "UID", "Name");
  else
      printf("%5s %5s %2s %4s %1s %7s %7s %3s %-8s %-15s %s\n", "PID", "TID", "PR", "CPU%", "S", "VSS", "RSS", "PCY", "UID", "Thread", "Proc");
#endif
  if (!threads) 
      printf("%5s %5s %-8s %1s %5s %7s %7s %5s %s\n", "PID", "PPID", "UID", "S", "#THR", "VSS", "RSS", "CPU%", "COMMAND");
  else
      printf("%5s %5s %2s %-8s %1s %7s %7s %5s %-15s %s\n", "PID", "TID", "PR", "UID", "S", "VSS", "RSS", "CPU%", "Thread", "Proc");

  rows--;

  for (i = 0; i < num_new_procs; i++) {
      proc = new_procs[i];

      if (!proc || (max_procs && (i >= max_procs)))
          break;
      user  = getpwuid(proc->uid);
      group = getgrgid(proc->gid);
      if (user && user->pw_name) {
          user_str = user->pw_name;
      } else {
          snprintf(user_buf, 20, "%d", proc->uid);
          user_str = user_buf;
      }
      if (group && group->gr_name) {
          group_str = group->gr_name;
      } else {
          snprintf(group_buf, 20, "%d", proc->gid);
          group_str = group_buf;
      }
      if (!threads)
      {
          printf("%5d %5d %-8.8s %c %5d %6ldK %6ldK %5s %s\n", proc->pid, proc->ppid, user_str, proc->state, proc->num_threads, 
                  proc->vss / 1024, proc->rss * getpagesize() / 1024, show_percent(proc->delta_time,  total_delta_time), proc->name[0] != 0 ? proc->name : proc->tname);
      }
      else
          printf("%5d %5d %2d %-8.8s %c %6ldK %6ldK %5s %-15s %s\n", proc->pid, proc->tid, proc->prs, user_str, proc->state,
                  proc->vss / 1024, proc->rss * getpagesize() / 1024, show_percent(proc->delta_time, total_delta_time), proc->tname, proc->name);
      rows--;
      if(rows == 0)
          break; //don't print any more process details.
  }
}

static struct proc_info *find_old_proc(pid_t pid, pid_t tid) {
  int i;

  for (i = 0; i < num_old_procs; i++)
      if (old_procs[i] && (old_procs[i]->pid == pid) && (old_procs[i]->tid == tid))
          return old_procs[i];

  return NULL;
}

static void free_old_procs(void) {
  int i;

  for (i = 0; i < num_old_procs; i++)
      if (old_procs[i])
          free_proc(old_procs[i]);

  free(old_procs);
}

static int proc_cpu_cmp(const void *a, const void *b) {
  struct proc_info *pa, *pb;

  pa = *((struct proc_info **)a); pb = *((struct proc_info **)b);

  if (!pa && !pb) return 0;
  if (!pa) return 1;
  if (!pb) return -1;

  return -numcmp(pa->delta_time, pb->delta_time);
}

static int proc_vss_cmp(const void *a, const void *b) {
  struct proc_info *pa, *pb;

  pa = *((struct proc_info **)a); pb = *((struct proc_info **)b);

  if (!pa && !pb) return 0;
  if (!pa) return 1;
  if (!pb) return -1;

  return -numcmp(pa->vss, pb->vss);
}

static int proc_rss_cmp(const void *a, const void *b) {
  struct proc_info *pa, *pb;

  pa = *((struct proc_info **)a); pb = *((struct proc_info **)b);

  if (!pa && !pb) return 0;
  if (!pa) return 1;
  if (!pb) return -1;

  return -numcmp(pa->rss, pb->rss);
}

static int proc_thr_cmp(const void *a, const void *b) {
  struct proc_info *pa, *pb;

  pa = *((struct proc_info **)a); pb = *((struct proc_info **)b);

  if (!pa && !pb) return 0;
  if (!pa) return 1;
  if (!pb) return -1;

  return -numcmp(pa->num_threads, pb->num_threads);
}

static int numcmp(long long a, long long b) {
  if (a < b) return -1;
  if (a > b) return 1;
  return 0;
}

static void usage(char *cmd) {
  fprintf(stderr, "Usage: %s [ -m max_procs ] [ -n iterations ] [ -d delay ] [ -s sort_column ] [ -t ] [ -h ]\n"
                  "    -m num  Maximum number of processes to display.\n"
                  "    -n num  Updates to show before exiting.\n"
                  "    -d num  Seconds to wait between updates.\n"
                  "    -s col  Column to sort by (cpu,vss,rss,thr).\n"
                  "    -t      Show threads instead of processes.\n"
                  "    -h      Display this help screen.\n",
      cmd);
}
